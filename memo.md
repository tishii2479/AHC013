# 考察

- 操作回数は少ない
- 一台あたり平均1回（繋ぐのも含めて）
    - 全部繋げようと思うと$100 * K - 1$回かかる、無理
- 大きさ$i,j$のクラスタを繋げると、スコアの増分は$i * j - (i + j)$
    - 両方が大きさ2以上のクラスタは繋げるとスコアが上がる
- できる限り大きいクラスタを作った方がいい
    - 小さいの何個もよりも大きいの1個
- 接続の必要な操作回数は$クラスタの大きさの総和 - 1$
- 繋げ方の検討
    - 長いケーブルを繋ぐのは良くない
- 遠いコンピュータを動かす時がある
    - 距離が正確じゃないことが原因
    - 移動距離の閾値を設けることで対処
- 操作回数が多すぎる時
    - 操作できなくなったら打ち切る
    - 操作回数の閾値を設けることである程度対処
- 空きマスがもったいない時は近づけた方がいい
    - 特に密な盤面とか
    - 今は移動距離を優先しているけど、ケーブルの距離も重視すべき
- 焼けるっちゃ焼けそう
    - なるべくalignな配置を作る
    - ケーブルの総距離が短い繋げかたを探す
- 時間は余っている
- 最初から多少違う種類があった方が良いかも
- スコアが低いのは
    - 盤面が密
    - K=2
        - costLimitを小さくするとよい
- 2つ大きいクラスタを作った方がいい
    - ある程度動かしてから焼きなましできそう

## TODO:

- 時間気にする

- Moveの回数減らす
- スコアの最大値を上げる

1. 2つ目のクラスタは横切れるようにする
    - 実装方針を考える
1. パラメータをN, Kごとに最適化
    - moveの回数が減る
1. 高速化
    - UnionFindに置き換える
1. ビームサーチっぽいのをやる
1. ケーブルの距離が長いものは却下する
1. 無駄な操作をなくす

## FIXME:

## 方針

### 方針1

- 一個コンピュータをランダムに選ぶ
- コンピュータを距離2(or1)以内の箇所に移動させた時のスコアを計算する
- スコアが最も上がるマスに動かす

- 1200くらい

### 方針2

- 一つの種類のコンピュータを優先して繋げる
- 全てのコンピュータの組を列挙
- 距離で近い順にソート（ここは工夫できそう）
- 違うクラスタにいるなら、くっつける
    - 動かした時、クラスタが崩れていない（前のクラスタが新しいクラスタに含まれている）ような動かしかたを探す
        - or スコアが上がるなら採用してもいいかも
    - そのうち、最もコストが少ない動かしかたを採用する
        - 他のコンピュータを動かすときは動かしたいマスに伝播させていく
            - 経路にない一番近い空きマスがわかればいい
        - 最終的にここを工夫することになりそう
    - くっつけるコストが大きすぎる（ケーブルの距離を含め）なら保留
    - 動かしてケーブルが切れてしまう可能性がある
        - 動かしたものは毎回繋ぎ直す or 切れないようにだけ動かす
    - 間にケーブルがないかはチェックする
- 繋げたケーブルは繋がっているコンピュータのIDを覚えておく
    - 動かしかたによっては切れてしまうよね。。。
- やり直しがないなら、UnionFindでよさそう

- 操作回数が足りなくなりそう（特にK=2）
- 混合のクラスタを作る方法を考える必要がありそう

- 余裕があるなら2つの種類で大きいクラスタを作る
    - スコアがいい方を選ぶ

- 同じよう二つコンピュータを繋げる
    - 間に違う種類のコンピュータがあっても許容（というより一緒につなげる）
    - どれくらいスコアが下がるかは考慮する必要がある（最悪、実際に計算すれば良い）
- 種類ごとのコンピュータのidの集合を作って、積集合を取ることで不純度がわかる

- クラスタの計算は繋がっているコンピュータだけで行う

- 0007みたいな密なケースがかなり厳しい

#### 考察

- 繋がりかたを覚えておく
- 左から繋がっているなら、右に動かしても大丈夫ではない
    - L字の真ん中だとダメ
    - 実際に動かしてクラスタが少なくならなければOK?
- 他の種類のコンピュータを動かすとき
    - ケーブルをまたがなければOK
    - 二つ以上動かす時は、動かしたいマスに伝播させていく
        - 一番近い空きマスがわかればいい

### 移動させる時

- 今繋がっているコンピュータのクラスタのサイズを全て引く
- 新しく繋がったコンピュータのクラスタのサイズを全てたす

## 評価関数

- ケーブルは短い方がいい
- 純度の高いクラスタの方がいい

## Ideas:

### Performance

- 上、左、右、下のコンピュータを持つ
- undo-可能なunionfindの導入
    - https://nyaannyaan.github.io/library/data-structure/rollback-union-find.hpp.html

```
Score distribution:
0000 ~ 0499:
0500 ~ 0999:
1000 ~ 1499:
1500 ~ 1999:
2000 ~ 2499:
2500 ~ 2999:
3000 ~ 3499: ooo
3500 ~ 3999: o
4000 ~ 4499:
4500 ~ 4999: oo
5000 ~ 5499: ooooooooooooooooooooooo
5500 ~ 5999: ooooooooooooooooooooooooooooooooooooooooo
6000 ~ 6499: oooooooooooooooooooooo
6500 ~ 6999: oooo
7000 ~ 7499: o
7500 ~ 7999:
8000 ~ 8499:
8500 ~ 8999:
9000 ~ 9499:
9500 ~ 9999:
Worst cases:
Case: 94, score: 3110
Case: 217, score: 3344
Case: 61, score: 3348
Case: 46, score: 3362
Case: 263, score: 3374
Case: 7, score: 3422
Case: 37, score: 3429
Case: 59, score: 3437
Case: 25, score: 3492
Case: 289, score: 3558
Best cases:
Case: 183, score: 7313
Case: 123, score: 7087
Case: 179, score: 7048
Case: 166, score: 7045
Case: 210, score: 7005
Case: 138, score: 6966
Case: 50, score: 6847
Case: 203, score: 6811
Case: 62, score: 6770
Case: 198, score: 6733
```