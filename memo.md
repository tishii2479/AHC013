# 考察

- 操作回数は少ない
- 一台あたり平均1回（繋ぐのも含めて）
    - 全部繋げようと思うと$100 * K - 1$回かかる、無理
- 大きさ$i,j$のクラスタを繋げると、スコアの増分は$i * j - (i + j)$
    - 両方が大きさ2以上のクラスタは繋げるとスコアが上がる
- できる限り大きいクラスタを作った方がいい
    - 小さいの何個もよりも大きいの1個
- 接続の必要な操作回数は$クラスタの大きさの総和 - 1$

## TODO:

- 繋げ方の検討
    - 長いケーブルを繋ぐのは良くない
- 遠いコンピュータを動かす時がある
- 操作回数が多すぎる時の対処

## FIXME:

- 動かした後で距離が変わっていることがある
- 遠い距離を動かすことになる

## 方針

### 方針1

- 一個コンピュータをランダムに選ぶ
- コンピュータを距離2(or1)以内の箇所に移動させた時のスコアを計算する
- スコアが最も上がるマスに動かす

- 1200くらい

### 方針2

- 一つの種類のコンピュータを優先して繋げる
- 全てのコンピュータの組を列挙
- 距離で近い順にソート（ここは工夫できそう）
- 違うクラスタにいるなら、くっつける
    - 動かした時、クラスタが崩れていない（前のクラスタが新しいクラスタに含まれている）ような動かしかたを探す
        - or スコアが上がるなら採用してもいいかも
    - そのうち、最もコストが少ない動かしかたを採用する
        - 他のコンピュータを動かすときは動かしたいマスに伝播させていく
            - 経路にない一番近い空きマスがわかればいい
        - 最終的にここを工夫することになりそう
    - くっつけるコストが大きすぎる（ケーブルの距離を含め）なら保留
    - 動かしてケーブルが切れてしまう可能性がある
        - 動かしたものは毎回繋ぎ直す or 切れないようにだけ動かす
    - 間にケーブルがないかはチェックする
- 繋げたケーブルは繋がっているコンピュータのIDを覚えておく
    - 動かしかたによっては切れてしまうよね。。。
- やり直しがないなら、UnionFindでよさそう

- 操作回数が足りなくなりそう（特にK=2）
- 混合のクラスタを作る方法を考える必要がありそう

- 余裕があるなら2つの種類で大きいクラスタを作る
    - スコアがいい方を選ぶ

- 同じよう二つコンピュータを繋げる
    - 間に違う種類のコンピュータがあっても許容（というより一緒につなげる）
    - どれくらいスコアが下がるかは考慮する必要がある（最悪、実際に計算すれば良い）
- 種類ごとのコンピュータのidの集合を作って、積集合を取ることで不純度がわかる

- クラスタの計算は繋がっているコンピュータだけで行う

- 0007みたいな密なケースがかなり厳しい

#### 考察

- 繋がりかたを覚えておく
- 左から繋がっているなら、右に動かしても大丈夫ではない
    - L字の真ん中だとダメ
    - 実際に動かしてクラスタが少なくならなければOK?
- 他の種類のコンピュータを動かすとき
    - ケーブルをまたがなければOK
    - 二つ以上動かす時は、動かしたいマスに伝播させていく
        - 一番近い空きマスがわかればいい

### 移動させる時

- 今繋がっているコンピュータのクラスタのサイズを全て引く
- 新しく繋がったコンピュータのクラスタのサイズを全てたす

## 評価関数

- ケーブルは短い方がいい
- 純度の高いクラスタの方がいい

## Ideas:

### Performance

- 上、左、右、下のコンピュータを持つ
- undo-可能なunionfindの導入
    - https://nyaannyaan.github.io/library/data-structure/rollback-union-find.hpp.html
