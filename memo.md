# 考察

- 操作回数は少ない
- 一台あたり平均1回（繋ぐのも含めて）
    - 全部繋げようと思うと$100 * K - 1$回かかる、無理
- 大きさ$i,j$のクラスタを繋げると、スコアの増分は$i * j - (i + j)$
    - 両方が大きさ2以上のクラスタは繋げるとスコアが上がる
- できる限り大きいクラスタを作った方がいい
    - 小さいの何個もよりも大きいの1個
- 接続の必要な操作回数は$クラスタの大きさの総和 - 1$
- 繋げ方の検討
    - 長いケーブルを繋ぐのは良くない
- 遠いコンピュータを動かす時がある
    - 距離が正確じゃないことが原因
    - 移動距離の閾値を設けることで対処
- 操作回数が多すぎる時
    - 操作できなくなったら打ち切る
    - 操作回数の閾値を設けることである程度対処
- 空きマスがもったいない時は近づけた方がいい
    - 特に密な盤面とか
    - 今は移動距離を優先しているけど、ケーブルの距離も重視すべき
- 焼けるっちゃ焼けそう
    - なるべくalignな配置を作る
    - ケーブルの総距離が短い繋げかたを探す
- 時間は余っている
- 最初から多少違う種類があった方が良いかも
- スコアが低いのは
    - 盤面が密
    - K=2
        - costLimitを小さくするとよい
- 2つ大きいクラスタを作った方がいい
    - ある程度動かしてから焼きなましできそう

## TODO:

1. パラメータをN, Kごとに最適化
    - Moveの回数減らす
1. ビームサーチっぽいのをやる
1. 高速化
    - getNearCompPair(_:)

## FIXME:

## 方針

### 方針1

- 一個コンピュータをランダムに選ぶ
- コンピュータを距離2(or1)以内の箇所に移動させた時のスコアを計算する
- スコアが最も上がるマスに動かす

- 1200くらい

### 方針2

- 一つの種類のコンピュータを優先して繋げる
- 全てのコンピュータの組を列挙
- 距離で近い順にソート（ここは工夫できそう）
- 違うクラスタにいるなら、くっつける
    - 動かした時、クラスタが崩れていない（前のクラスタが新しいクラスタに含まれている）ような動かしかたを探す
        - or スコアが上がるなら採用してもいいかも
    - そのうち、最もコストが少ない動かしかたを採用する
        - 他のコンピュータを動かすときは動かしたいマスに伝播させていく
            - 経路にない一番近い空きマスがわかればいい
        - 最終的にここを工夫することになりそう
    - くっつけるコストが大きすぎる（ケーブルの距離を含め）なら保留
    - 動かしてケーブルが切れてしまう可能性がある
        - 動かしたものは毎回繋ぎ直す or 切れないようにだけ動かす
    - 間にケーブルがないかはチェックする
- 繋げたケーブルは繋がっているコンピュータのIDを覚えておく
    - 動かしかたによっては切れてしまうよね。。。
- やり直しがないなら、UnionFindでよさそう

- 操作回数が足りなくなりそう（特にK=2）
- 混合のクラスタを作る方法を考える必要がありそう

- 余裕があるなら2つの種類で大きいクラスタを作る
    - スコアがいい方を選ぶ

- 同じよう二つコンピュータを繋げる
    - 間に違う種類のコンピュータがあっても許容（というより一緒につなげる）
    - どれくらいスコアが下がるかは考慮する必要がある（最悪、実際に計算すれば良い）
- 種類ごとのコンピュータのidの集合を作って、積集合を取ることで不純度がわかる

- クラスタの計算は繋がっているコンピュータだけで行う

- 0007みたいな密なケースがかなり厳しい

#### 考察

- 繋がりかたを覚えておく
- 左から繋がっているなら、右に動かしても大丈夫ではない
    - L字の真ん中だとダメ
    - 実際に動かしてクラスタが少なくならなければOK?
- 他の種類のコンピュータを動かすとき
    - ケーブルをまたがなければOK
    - 二つ以上動かす時は、動かしたいマスに伝播させていく
        - 一番近い空きマスがわかればいい

### 移動させる時

- 今繋がっているコンピュータのクラスタのサイズを全て引く
- 新しく繋がったコンピュータのクラスタのサイズを全てたす

## 評価関数

- ケーブルは短い方がいい
- 純度の高いクラスタの方がいい

## Ideas:

### Performance

- 上、左、右、下のコンピュータを持つ
- undo-可能なunionfindの導入
    - https://nyaannyaan.github.io/library/data-structure/rollback-union-find.hpp.html

```
[RESULT] Average is 6478.583333333333 : ./main.o
[RESULT] Max score average is 6478.583333333333 : ./main.o
Score distribution:
0000 ~ 0499:
0500 ~ 0999:
1000 ~ 1499:
1500 ~ 1999:
2000 ~ 2499:
2500 ~ 2999:
3000 ~ 3499:
3500 ~ 3999: ooo
4000 ~ 4499:
4500 ~ 4999: o
5000 ~ 5499: oooooooo
5500 ~ 5999: oooooooooooo
6000 ~ 6499: oooooooooooooooooooooooooooo
6500 ~ 6999: ooooooooooooooooo
7000 ~ 7499: ooooooooooooo
7500 ~ 7999: oooooooooo
8000 ~ 8499: oo
8500 ~ 8999: oo
9000 ~ 9499:
9500 ~ 9999:
Worst cases:
Case: 263, score: 3264
Case: 217, score: 3416
Case: 94, score: 3522
Case: 7, score: 3588
Case: 289, score: 3621
Case: 59, score: 3639
Case: 255, score: 3726
Case: 61, score: 3730
Case: 25, score: 3740
Case: 9, score: 3771
Best cases:
Case: 235, score: 8895
Case: 19, score: 8866
Case: 99, score: 8784
Case: 127, score: 8692
Case: 191, score: 8542
Case: 211, score: 8523
Case: 171, score: 8437
Case: 43, score: 8375
Case: 183, score: 8275
Case: 47, score: 8256
```
