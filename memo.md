# 考察

- 操作回数は少ない
- 一台あたり平均1回（繋ぐのも含めて）
    - 全部繋げようと思うと$100 * K - 1$回かかる、無理
- 大きさ$i,j$のクラスタを繋げると、スコアの増分は$i * j - (i + j)$
    - 両方が大きさ2以上のクラスタは繋げるとスコアが上がる
- できる限り大きいクラスタを作った方がいい
    - 小さいの何個もよりも大きいの1個
- 接続の必要な操作回数は$クラスタの大きさの総和 - 1$
- 繋げ方の検討
    - 長いケーブルを繋ぐのは良くない
- 遠いコンピュータを動かす時がある
    - 距離が正確じゃないことが原因
    - 移動距離の閾値を設けることで対処
- 操作回数が多すぎる時
    - 操作できなくなったら打ち切る
    - 操作回数の閾値を設けることである程度対処
- 空きマスがもったいない時は近づけた方がいい
    - 特に密な盤面とか
    - 今は移動距離を優先しているけど、ケーブルの距離も重視すべき
- 焼けるっちゃ焼けそう
    - なるべくalignな配置を作る
    - ケーブルの総距離が短い繋げかたを探す
- 時間は余っている
- 最初から多少違う種類があった方が良いかも
- スコアが低いのは
    - 盤面が密
    - K=2
        - costLimitを小さくするとよい
- 2つ大きいクラスタを作った方がいい
    - ある程度動かしてから焼きなましできそう

## TODO:

1. K=2の時
1. ビームサーチっぽいのをやる

## FIXME:

## 方針

### 方針1

- 一個コンピュータをランダムに選ぶ
- コンピュータを距離2(or1)以内の箇所に移動させた時のスコアを計算する
- スコアが最も上がるマスに動かす

- 1200くらい

### 方針2

- 一つの種類のコンピュータを優先して繋げる
- 全てのコンピュータの組を列挙
- 距離で近い順にソート（ここは工夫できそう）
- 違うクラスタにいるなら、くっつける
    - 動かした時、クラスタが崩れていない（前のクラスタが新しいクラスタに含まれている）ような動かしかたを探す
        - or スコアが上がるなら採用してもいいかも
    - そのうち、最もコストが少ない動かしかたを採用する
        - 他のコンピュータを動かすときは動かしたいマスに伝播させていく
            - 経路にない一番近い空きマスがわかればいい
        - 最終的にここを工夫することになりそう
    - くっつけるコストが大きすぎる（ケーブルの距離を含め）なら保留
    - 動かしてケーブルが切れてしまう可能性がある
        - 動かしたものは毎回繋ぎ直す or 切れないようにだけ動かす
    - 間にケーブルがないかはチェックする
- 繋げたケーブルは繋がっているコンピュータのIDを覚えておく
    - 動かしかたによっては切れてしまうよね。。。
- やり直しがないなら、UnionFindでよさそう

- 操作回数が足りなくなりそう（特にK=2）
- 混合のクラスタを作る方法を考える必要がありそう

- 余裕があるなら2つの種類で大きいクラスタを作る
    - スコアがいい方を選ぶ

- 同じよう二つコンピュータを繋げる
    - 間に違う種類のコンピュータがあっても許容（というより一緒につなげる）
    - どれくらいスコアが下がるかは考慮する必要がある（最悪、実際に計算すれば良い）
- 種類ごとのコンピュータのidの集合を作って、積集合を取ることで不純度がわかる

- クラスタの計算は繋がっているコンピュータだけで行う

- 0007みたいな密なケースがかなり厳しい

#### 考察

- 繋がりかたを覚えておく
- 左から繋がっているなら、右に動かしても大丈夫ではない
    - L字の真ん中だとダメ
    - 実際に動かしてクラスタが少なくならなければOK?
- 他の種類のコンピュータを動かすとき
    - ケーブルをまたがなければOK
    - 二つ以上動かす時は、動かしたいマスに伝播させていく
        - 一番近い空きマスがわかればいい

### 移動させる時

- 今繋がっているコンピュータのクラスタのサイズを全て引く
- 新しく繋がったコンピュータのクラスタのサイズを全てたす

## 評価関数

- ケーブルは短い方がいい
- 純度の高いクラスタの方がいい

## Ideas:

### Performance

- 上、左、右、下のコンピュータを持つ
- undo-可能なunionfindの導入
    - https://nyaannyaan.github.io/library/data-structure/rollback-union-find.hpp.html

```
[RESULT] Average is 6711.846 : ./main.o
Score distribution:
0000 ~ 0499:
0500 ~ 0999:
1000 ~ 1499:
1500 ~ 1999:
2000 ~ 2499:
2500 ~ 2999:
3000 ~ 3499: oo
3500 ~ 3999: oo
4000 ~ 4499:
4500 ~ 4999:
5000 ~ 5499: ooooooo
5500 ~ 5999: ooooooooooooo
6000 ~ 6499: oooooooooooooo
6500 ~ 6999: ooooooooooooo
7000 ~ 7499: ooooooooooooooooooo
7500 ~ 7999: oooooooooooooo
8000 ~ 8499: oooooooo
8500 ~ 8999: ooo
9000 ~ 9499:
9500 ~ 9999:
Worst cases:
Case: 330, score: 3015
Case: 479, score: 3237
Case: 462, score: 3246
Case: 342, score: 3268
Case: 313, score: 3285
Case: 346, score: 3327
Case: 494, score: 3336
Case: 94, score: 3406
Case: 263, score: 3494
Case: 461, score: 3495
Best cases:
Case: 15, score: 9101
Case: 243, score: 9048
Case: 123, score: 8876
Case: 471, score: 8866
Case: 83, score: 8790
Case: 215, score: 8781
Case: 359, score: 8779
Case: 447, score: 8778
Case: 127, score: 8701
Case: 435, score: 8694
```
